<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Sans Serif:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="引言最近对ReactiveX的RxJava觉得很赞，但其实，Java8的Stream难道就不赞了吗，Java的不断发展，Stream出现了，用了一下，的确觉得很赞，感觉RxJava和Java8的Stream在使用上特别像，很多操作符都是一样的，使用下来，就感觉数据对于我们来说就是流水(River)，这是我自己的比喻哈，对流水各种处理，最后得到我们想要的。我不知道两者到底谁借鉴谁，但是觉得属于一派，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8的Stream是时候用起来了">
<meta property="og:url" content="http://yoursite.com/2016/09/07/Java8的Stream是时候用起来了/index.html">
<meta property="og:site_name" content="Gordon's Blog">
<meta property="og:description" content="引言最近对ReactiveX的RxJava觉得很赞，但其实，Java8的Stream难道就不赞了吗，Java的不断发展，Stream出现了，用了一下，的确觉得很赞，感觉RxJava和Java8的Stream在使用上特别像，很多操作符都是一样的，使用下来，就感觉数据对于我们来说就是流水(River)，这是我自己的比喻哈，对流水各种处理，最后得到我们想要的。我不知道两者到底谁借鉴谁，但是觉得属于一派，">
<meta property="og:updated_time" content="2016-09-19T02:41:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8的Stream是时候用起来了">
<meta name="twitter:description" content="引言最近对ReactiveX的RxJava觉得很赞，但其实，Java8的Stream难道就不赞了吗，Java的不断发展，Stream出现了，用了一下，的确觉得很赞，感觉RxJava和Java8的Stream在使用上特别像，很多操作符都是一样的，使用下来，就感觉数据对于我们来说就是流水(River)，这是我自己的比喻哈，对流水各种处理，最后得到我们想要的。我不知道两者到底谁借鉴谁，但是觉得属于一派，">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Java8的Stream是时候用起来了 | Gordon's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Gordon's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">still believe in that world can be reshaped by coding and we can benifit from it.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Blogs
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Timeline
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java8的Stream是时候用起来了
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-07T11:19:23+08:00" content="2016-09-07">
              2016-09-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>最近对ReactiveX的RxJava觉得很赞，但其实，Java8的Stream难道就不赞了吗，Java的不断发展，Stream出现了，用了一下，的确觉得很赞，感觉RxJava和Java8的Stream在使用上特别像，很多操作符都是一样的，使用下来，就感觉数据对于我们来说就是流水(River)，这是我自己的比喻哈，对流水各种处理，最后得到我们想要的。我不知道两者到底谁借鉴谁，但是觉得属于一派，好了，逼逼半天，结合网上看到的别人的博客，总结一下，写文章不是为了装逼，我认为我的博客是我的笔记本，记录一些我想翻阅的资料，至少它不会随着时间的流逝而消失。<a id="more"></a></p>
<p>JAVA8中的stream API与JAVA I/O中的InputStream和OutputStream在名字上比较类似，但是其实是另外一个东西，Stream API是JAVA函数式编程中的一个重要组成部分。</p>
<p>本文描述如何使用JAVA8的Stream API。通过本文，你可以了解Stream API的执行顺序，不同的执行顺序会对stream api的执行效率有较大的影响。本文会详细描述Stream API中的reduce，collect，flatMap等操作，结尾部分会深入讲解parallel streams。</p>
<h4 id="Streams如何工作？"><a href="#Streams如何工作？" class="headerlink" title="Streams如何工作？"></a>Streams如何工作？</h4><p>stream是一个可以对个序列中的元素执行各种计算操作的一个元素序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; myList =</span><br><span class="line">    Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>);</span><br><span class="line"></span><br><span class="line">myList</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"c"</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// C1</span></span><br><span class="line"><span class="comment">// C2</span></span><br><span class="line">----------------</span><br></pre></td></tr></table></figure></p>
<p>stream包含中间（intermediate operations）和最终（terminal operation）两种形式的操作。中间操作（intermediate operations）的返回值还是一个stream，因此可以通过链式调用将中间操作（intermediate operations）串联起来。最终操作（terminal operation）只能返回void或者一个非stream的结果。在上述例子中：filter, map ，sorted是中间操作，而forEach是一个最终操作。更多关于stream的中可用的操作可以查看java doc。上面例子中的链式调用也被称为操作管道流。</p>
<p>大多stream操作接受某种形式的lambda表达式作为参数，通过方法接口的形式指定操作的具体行为，这些方法接口的行为基本上都是无干扰(non-interfering)和无状态(stateless)。无干扰(non-interfering)的方法的定义是：该方法不修改stream的底层数据源,比如上述例子中：没有lambda表达式添加或者删除myList中的元素。无状态(stateless)方法的定义：操作的执行是独立的，比如上述例子中，没有lambda表达式在执行中依赖可能发生变化的外部变量或状态。</p>
<h4 id="streams分类"><a href="#streams分类" class="headerlink" title="streams分类"></a>streams分类</h4><p>可以从不同的数据源创建stream。java collection包中的Collections，Lists，Sets这些类中新增stream()和parallelStream()方法，通过这些方法可以创建一个顺序stream（sequential streams）或者一个并发的stream(Parallel streams)。并发stream(Parallel streams)更适合在多线程中使用，本文先介绍顺序流（sequential streams）在结尾会描述并发stream(Parallel streams).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// a1</span></span><br></pre></td></tr></table></figure></p>
<p>List对象上调用stream()方法可以返回一个常规的对象流。在下面的例子中我们不需要创建一个collection对象也可以使用stream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// a1</span></span><br></pre></td></tr></table></figure>
<p>直接使用Stream.of()方法就能从一组对象创建一个stream对象，</p>
<p>除了常规的对象流，JAVA 8中的IntStream,LongStream,DoubleStream这些流能够处理基本数据类型如：int,long,double。比如：IntStream可以使用range()方法能够替换掉传统的for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>基本类型流（primitive streams）使用方式与常规对象流类型（regular object streams）大部分相同，但是基本类型流（primitive streams）能使用一些特殊的lambda表达式，比如：用IntFunction代替Function，用IntPredicate代替Predicate，同时基本类型流（primitive streams）中可以支持一些聚合方法，如：sum()，average()等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">    .average()</span><br><span class="line">    .ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
<p>可以通过常规对象流（regular object stream）的mapToInt(), mapToLong()，mapToDouble()，基本类型对象流（primitive streams）中的mapToObj()等方法完成常规对象流和基本类型流之间的相互转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子中doubles stream先被映射成int stream，然后又被映射成String类型的对象流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    .mapToInt(Double::intValue)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure></p>
<h4 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h4><p>前面描述了如何创建和使用各种stream，现在开始深入了解stream执行引擎的工作原理。</p>
<p>Laziness（延迟加载）是中间操作（intermediate operations）的一个重要特性。如下面这个例子：中间操作（terminal operation）缺失，当执行这个代码片段的时候，并不会在控制台打印相应的内容，这是因为只有最终操作（terminal operation）存在的时候，中间操作（intermediate operations）才会执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>给上面的例子添加最终操作（terminal operation）forEach：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line">filter:  d2</span><br><span class="line">forEach: d2</span><br><span class="line">filter:  a2</span><br><span class="line">forEach: a2</span><br><span class="line">filter:  b1</span><br><span class="line">forEach: b1</span><br><span class="line">filter:  b3</span><br><span class="line">forEach: b3</span><br><span class="line">filter:  c</span><br><span class="line">forEach: c</span><br></pre></td></tr></table></figure>
<p>执行结果比较让人惊奇，想当然的做法是水平执行此流上的所有元素。但是实际上是每一个元素沿着链垂直移动，第一个字符串”d2”执行完filter和forEach后第二个元素”a2”才开始执行。</p>
<p>这种沿着链垂直移动的行为可以降低每一个元素上进行操作的数量，如我们在下面的例子中所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;最终操作</span><br><span class="line">        System.out.println(<span class="string">"anyMatch: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// map:      d2</span></span><br><span class="line"><span class="comment">// anyMatch: D2</span></span><br><span class="line"><span class="comment">// map:      a2</span></span><br><span class="line"><span class="comment">// anyMatch: A2</span></span><br></pre></td></tr></table></figure>
<p>当对给定元素执行判断为真时anyMatch操作会立刻返回true，在上面例子中执行到元素“A2”的时候，元素判断为真anyMatch立刻返回true，由于流是沿着链垂直移动的，因此上面的map操作只会执行两次。</p>
<h4 id="执行效率与steream执行链顺序的关系"><a href="#执行效率与steream执行链顺序的关系" class="headerlink" title="执行效率与steream执行链顺序的关系"></a>执行效率与steream执行链顺序的关系</h4><p>下面的例子由两个中间操作（intermediate operations）map和filter以及一个最终操作（terminal operation）forEach构成，我们观察这些动作是如何执行的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// map:     d2</span></span><br><span class="line"><span class="comment">// filter:  D2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// filter:  A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map:     b1</span></span><br><span class="line"><span class="comment">// filter:  B1</span></span><br><span class="line"><span class="comment">// map:     b3</span></span><br><span class="line"><span class="comment">// filter:  B3</span></span><br><span class="line"><span class="comment">// map:     c</span></span><br><span class="line"><span class="comment">// filter:  C</span></span><br></pre></td></tr></table></figure></p>
<p>你可能已经猜想到：map和filter操作被执行了5次，但是forEach操作只被执行了1次。我们可以通过修改操作的执行顺序（如：将filter操作移到操作链的头部），大幅度降低执行次数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter:  b1中间操作</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br></pre></td></tr></table></figure></p>
<p>修改后map只被执行了1次，如果此时数据量比较大则操作管道的执行效率会有较大的提升，在处理复杂方法链的时候需要注意执行顺序对执行效率的影响。</p>
<p>给上面的例子添加sort操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sort: %s; %s\n"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">//sort:    a2; d2</span></span><br><span class="line"><span class="comment">//sort:    b1; a2</span></span><br><span class="line"><span class="comment">//sort:    b1; d2</span></span><br><span class="line"><span class="comment">//sort:    b1; a2</span></span><br><span class="line"><span class="comment">//sort:    b3; b1</span></span><br><span class="line"><span class="comment">//sort:    b3; d2</span></span><br><span class="line"><span class="comment">//sort:    c; b3</span></span><br><span class="line"><span class="comment">//sort:    c; d2</span></span><br><span class="line"><span class="comment">//filter:  a2</span></span><br><span class="line"><span class="comment">//map:     a2</span></span><br><span class="line"><span class="comment">//forEach: A2</span></span><br><span class="line"><span class="comment">//filter:  b1</span></span><br><span class="line"><span class="comment">//filter:  b3</span></span><br><span class="line"><span class="comment">//filter:  c</span></span><br><span class="line"><span class="comment">//filter:  d2</span></span><br></pre></td></tr></table></figure></p>
<p>Sorting 是一种特殊的中间操作（intermediate operation），在对集合中元素进行排序过程中需要保存元素的状态，因此Sorting 是一种有状态的操作（stateful operation）。</p>
<p>首先，在整个输入集上执行排序操作（即先对集合进行水平操作），由于输入集合中的元素间存在多种组合，因此上面的例子中sorted操作被执行了8次。</p>
<p>可以通过对执行链重排序的方式，提升stream的执行效率。修改执行链顺序之后由于filter操作的过滤，导致sorted操作的输入集只有一个元素，在大数据量的情况下能够大幅度提高执行效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sort: %s; %s\n"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br></pre></td></tr></table></figure>
<h4 id="流复用"><a href="#流复用" class="headerlink" title="流复用"></a>流复用</h4><p>Java 8 streams不能被复用，当你执行完任何一个最终操作（terminal operation）的时候流就被关闭了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">    Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="keyword">true</span>);    <span class="comment">// ok</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// exception</span></span><br></pre></td></tr></table></figure></p>
<p>在同一个stream中执行完anyMatch后再执行noneMatch就会抛出如下异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="number">459</span>)</span><br><span class="line">    at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="number">38</span>)</span><br><span class="line">    at com.winterbe.java8.Streams5.main(Streams5.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure>
<p>可以通过为每个最终操作（terminal operation）创建一个新的stream链的方式来解决上面的重用问题，Stream api中已经提供了一个stream supplier类来在已经存在的中间操作（intermediate operations ）的stream基础上构建一个新的stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// ok</span></span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="keyword">true</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>streamSupplier的每个get()方法会构造一个新的stream，我们可以在这个stream上执行期望的最终操作（terminal operation）。</p>
<h4 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h4><p>Streams支持多种不同的操作（operations），我们已经了解过filter，map等比较重要的操作。你可以通过Stream Javadoc进一步了解更多的操作。现在我们开始深入探讨更复杂的操作：collect flatMap reduce。<br>假设存在如下的用户列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons =</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Max"</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Peter"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Pamela"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"David"</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure></p>
<h5 id="Collect-收集"><a href="#Collect-收集" class="headerlink" title="Collect(收集)"></a>Collect(收集)</h5><p>Collect（收集）是一种是十分有用的最终操作，它可以把stream中的元素转换成另外一种形式，比如；list，set，map。Collect使用Collector作为参数，Collector包含四种不同的操作：supplier（初始构造器）, accumulator（累加器）, combiner（组合器）， finisher（终结者）。这听起来很复杂，但是一个好消息是java 8通过Collectors类内置了各种复杂的收集操作，因此对于大部分常用的操作来说，你不需要自己去实现collector类。</p>
<p>从一个十分常见的用类开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.name.startsWith(<span class="string">"P"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filtered);    </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// [Peter, Pamela]</span></span><br></pre></td></tr></table></figure>
<p>通过上面的demo可以看出，将stream转换为List十分简单，如果想转换为Set的话，只需使用Collectors.toSet()就可以了。</p>
<p>下面的例子暂时将用户按年龄分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">personsByAge</span><br><span class="line">    .forEach((age, p) -&gt; System.out.format(<span class="string">"age %s: %s\n"</span>, age, p));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// age 18: [Max]</span></span><br><span class="line"><span class="comment">// age 23: [Peter, Pamela]</span></span><br><span class="line"><span class="comment">// age 12: [David]</span></span><br></pre></td></tr></table></figure>
<p>Collectors类功能繁多，你可以通过Collectors对stream中的元素进行汇聚，比如：计算所有用户的年纪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Double averageAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------  </span><br><span class="line">// 19.0</span><br></pre></td></tr></table></figure>
<p>可以通过summarizing collectors能返回一个内置的统计对象，通过这个对象能够获取更加全面的统计信息，比如用户年纪中的最大值，最小值，平均年纪等结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageSummary =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子展示如何将所有用户连接成一个字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String phrase = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(p -&gt; p.name)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">" and "</span>, <span class="string">"In Germany "</span>, <span class="string">" are of legal age."</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// In Germany Max and Peter and Pamela are of legal age.</span></span><br></pre></td></tr></table></figure></p>
<p>join collector的三个参数分别表示：连接符，字符串前缀，字符串后缀（可选）。</p>
<p>将一个stream转换为map，我们必须指定map的key和value如何映射。要注意的是key的值必须是唯一性的，否则会抛出IllegalStateException，但是可以通过使用合并函数（可选）绕过这个IllegalStateException异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        p -&gt; p.age,</span><br><span class="line">        p -&gt; p.name,</span><br><span class="line">        (name1, name2) -&gt; name1 + <span class="string">";"</span> + name2));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// &#123;18=Max, 23=Peter;Pamela, 12=David&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>前文已经介绍了jdk内置的一些很有用的collectors，接下来开始介绍如何构造我们自己所需的collector，我们的目标是将stream中所有用户的用户名变成大写并用”|”符号连接成一个字符串。为了达成这个目标我们通过Collector.of()方法创建了一个新的collector，我们必须给这个collector提供四种功能：supplier, accumulator, combiner,finisher.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =</span><br><span class="line">    Collector.of(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> StringJoiner(<span class="string">" | "</span>),          <span class="comment">// supplier</span></span><br><span class="line">        (j, p) -&gt; j.add(p.name.toUpperCase()),  <span class="comment">// accumulator</span></span><br><span class="line">        (j1, j2) -&gt; j1.merge(j2),               <span class="comment">// combiner</span></span><br><span class="line">        StringJoiner::toString);                <span class="comment">// finisher</span></span><br><span class="line"></span><br><span class="line">String names = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(personNameCollector);</span><br><span class="line"></span><br><span class="line">System.out.println(names);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// MAX | PETER | PAMELA | DAVID</span></span><br></pre></td></tr></table></figure>
<p>由于JAVA中String是一个不可变对象，因此我们需要一个辅助类（比如StringJoiner）来帮助collect构造我们的字符串。supplier创建了一个包含适当分隔符的StringJoiner对象，accumulator用来将每个用户名转为大写并添加到supplier创建的StringJoiner中，combiner将两个StringJoiners对象连接成一个，最后一步的finisher从StringJoiner中构建出所希望的得到的string对象。</p>
<h5 id="FlatMap（平铺变换，我自己这么叫的）"><a href="#FlatMap（平铺变换，我自己这么叫的）" class="headerlink" title="FlatMap（平铺变换，我自己这么叫的）"></a>FlatMap（平铺变换，我自己这么叫的）</h5><p>我们已经了解：通过map方法可以将stream中的一种对象转换成另外一种对象。但是map方法还是有使用场景限制，只能将一种对象映射为另外一种特定的已经存在的对象。是否能够将一个对象映射为多种对象，或者映射成一个根本不存在的对象呢。这就是flatMap方法出现的目的。</p>
<p>FlatMap方法可以将一个stream中的每一个元素对象转换为另一个stream中的另一种元素对象，因此可以将stream中的每个对象改造成零，一个或多个。flatMap操作的返回流包含这些改造后的对象。</p>
<p>为了演示flatMap，定义一个继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Bar&gt; bars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Bar(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过流实例化一队对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Foo&gt; foos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create foos</span></span><br><span class="line">IntStream</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(i -&gt; foos.add(<span class="keyword">new</span> Foo(<span class="string">"Foo"</span> + i)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create bars</span></span><br><span class="line">foos.forEach(f -&gt;</span><br><span class="line">    IntStream</span><br><span class="line">        .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .forEach(i -&gt; f.bars.add(<span class="keyword">new</span> Bar(<span class="string">"Bar"</span> + i + <span class="string">" &lt;- "</span> + f.name))));</span><br></pre></td></tr></table></figure></p>
<p>完成上述操作之后我们得到三个foos，每个foos包含三个bars。</p>
<p>FlatMap接收一个返回值为stream的函数做参数，通过传递合适的函数，就可以解析每一个foo下对应的bar对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foos.stream()</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo3</span></span><br></pre></td></tr></table></figure>
<p>正如所见，我们成功地将三个对象的stream转换成一个包含九个对象的stream</p>
<p>最后，上面的示例代码可以简化为一个单一管道流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="keyword">new</span> Foo(<span class="string">"Foo"</span> + i))</span><br><span class="line">    .peek(f -&gt; IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .mapToObj(i -&gt; <span class="keyword">new</span> Bar(<span class="string">"Bar"</span> + i + <span class="string">" &lt;- "</span> f.name))</span><br><span class="line">        .forEach(f.bars::add))</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br></pre></td></tr></table></figure></p>
<p>FlatMap也支持JAVA8中新引入的Optional类，Optionals flatMap能返回一个另外的类的optional包装类，可以用来减少对null的检查。</p>
<p>假设有如下这种多层级结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    Nested nested;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">    Inner inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了获取内部outer实例的内部foo对象，需要添加一系列空指针判断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="keyword">if</span> (outer != <span class="keyword">null</span> &amp;&amp; outer.nested != <span class="keyword">null</span> &amp;&amp; outer.nested.inner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以采用optionals flatMap 操作获得相同的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(<span class="keyword">new</span> Outer())</span><br><span class="line">    .flatMap(o -&gt; Optional.ofNullable(o.nested))</span><br><span class="line">    .flatMap(n -&gt; Optional.ofNullable(n.inner))</span><br><span class="line">    .flatMap(i -&gt; Optional.ofNullable(i.foo))</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中flatMap的每次调用都会返回一个用Optional对象，如果有返回值则这个Optional对象是这个返回值的包装类，如果返回值不存在则返回null。</p>
<h5 id="Reduce（归并）"><a href="#Reduce（归并）" class="headerlink" title="Reduce（归并）"></a>Reduce（归并）</h5><p>reduce操作可以将stream中所有元素组合起来得到一个元素，JAVA8支持三中不同的reduce方法。</p>
<p>第一种能从stream元素序列中提取一个特定的元素。比如下面的从用户列表中选择年纪最大的用户操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);    </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// Pamela</span></span><br></pre></td></tr></table></figure></p>
<p>上面的实例中reduce方法接收一个二元累加计算函数（BinaryOperator accumulator function）作为参数，二元操作（BinaryOperator）实际就是上在两个操作数共享同一类型。示例中函数比较两人年龄，返回的最大年龄的人。</p>
<p>第二种reduce操作接收一个标识值和一个二元操作累加器作为参数，这个reduce方法可以把stream中所有用户的名字和年龄汇总得到一个新用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Person result =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"name=%s; age=%s"</span>, result.name, result.age);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// name=MaxPeterPamelaDavid; age=76</span></span><br></pre></td></tr></table></figure>
<p>第三种reduce方法，接收三个参数：一个标示值（identity value），一个二元操作累加器（BiFunction accumulator），一个二元组合方法。由于标识符参数未被严格限制为person类型，因此我们可以用这个reduce方法来获取用户的总年龄。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line"></span><br><span class="line">System.out.println(ageSum);  </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// 76</span></span><br></pre></td></tr></table></figure>
<p>计算的结果是76，通过添加调试输出，我们可以详细地了解执行引擎中发生了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=18; person=Peter</span></span><br><span class="line"><span class="comment">// accumulator: sum=41; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=64; person=David</span></span><br></pre></td></tr></table></figure>
<p>从调试输出中可以看到，累加器做了所有的工作，它首先获取值为0的标示值和第一个用户Max，接下来的三步中持续sum值由于累加不断变大，在最后一步汇总的年纪增长到76。</p>
<p>注意，上面的调试输出中combiner没有执行，通过parallel执行上面相同stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=David</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Peter</span></span><br><span class="line"><span class="comment">// combiner: sum1=18; sum2=23</span></span><br><span class="line"><span class="comment">// combiner: sum1=23; sum2=12</span></span><br><span class="line"><span class="comment">// combiner: sum1=41; sum2=35</span></span><br></pre></td></tr></table></figure>
<p>通过并行的方式执行上面的stream操作，得到的是另外一种完全不相同的执行动作。在并行stream中combiner方法会被调用。这是由于累加器是被并行调用的，因此组合器需要对分开的累加操作进行求和。</p>
<h4 id="Parallel-Streams（并行流）"><a href="#Parallel-Streams（并行流）" class="headerlink" title="Parallel Streams（并行流）"></a>Parallel Streams（并行流）</h4><p>为了提高大量输入时的执行效率，stream可以采用并行的放行执行。并行流（Parallel Streams）通过ForkJoinPool.commonPool() 方法获取一个可用的ForkJoinPool。这个ForkJoinPool使用5个线程（实际上是由底层可用的物理cpu核数决定的）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());    </span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>在我的机器上公共池初始化为每个默认3并行，这个值可以通过调整jvm参数来修改：</p>
<p>-Djava.util.concurrent.ForkJoinPool.common.parallelism=5<br>Collections中包含parallelStream()方法，通过这个方法能够为Collections中的元素创建并行流。另外也可以调用stream的parallel()方法将一个顺序流转变为一个并行流的拷贝。</p>
<p>为了了解并行流的执行动作，下面的例子会打印当前线程的执行信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"filter: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"map: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">"forEach: %s [%s]\n"</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line">filter:  b1 [main]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>通过分析调试输出，我们可以更好地了解哪一个线程执行了哪些stream操作。从上面的输出中我们可以看到parallel stream使用了ForkJoinPool提供的所有可用的线程来执行流的各种操作。由于不能确定哪个线程会执行并行流的哪个操作，因此反复执行上面的代码，打印的结果会不同。</p>
<p>扩充上面的例子，添加sort操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"filter: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"map: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"sort: %s &lt;&gt; %s [%s]\n"</span>,</span><br><span class="line">            s1, s2, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">"forEach: %s [%s]\n"</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">filter:  b1 [main]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">sort:    A2 &lt;&gt; A1 [main]</span><br><span class="line">sort:    B1 &lt;&gt; A2 [main]</span><br><span class="line">sort:    C2 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">sort:    C1 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>这个执行结果看起来比较奇怪，看起来sort操作只是在main线程中顺序执行的。实际上，parallel stream中的sort操作使用了JAVA 8的一个新方法：Arrays.parallelSort()。JAVA doc中是这样描述Arrays.parallelSort()的：待排序数组的长度决定了排序操作是顺序执行还是并行执行。java doc 描述如下：</p>
<p>If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate Arrays.sort method.<br>回到上一章的例子，我们已经了解combiner方法只能在parallel streams中调用，让我们来看下那些线程被实际调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Max"</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Peter"</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Pamela"</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"David"</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s [%s]\n"</span>,</span><br><span class="line">                sum, p, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s [%s]\n"</span>,</span><br><span class="line">                sum1, sum2, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">----------------</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=Pamela; [main]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=Max;    [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=David;  [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=Peter;  [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">combiner:    sum1=<span class="number">18</span>; sum2=<span class="number">23</span>;     [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">combiner:    sum1=<span class="number">23</span>; sum2=<span class="number">12</span>;     [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">combiner:    sum1=<span class="number">41</span>; sum2=<span class="number">35</span>;     [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>从控制台输出可以看到accumulator和combiner操作都被可用的线程并行执行了。</p>
<p>总结起来：在大数据量输入的时候，parallel streams可以带来比较大的性能提升。但是应该记住，一些并行操作，比如：reduce，collect需要额外的计算（组合操作），但是在顺序流中，这些组合操作是不需要的。</p>
<p>另外，我们知道所有的parallel stream操作共享一个jvm范围内的ForkJoinPool，所以你应该注意避免在parallel stream上执行慢阻塞流操作，因为这些操作可能导致你应用中依赖parallel streams操作的其他部分也会响应变慢。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java8的Stream我认为是借鉴了别的语言的优点，换种思路在写程序，考虑到各种各样的场景，对于我来说，我觉得Stream可以有效的处理数据，新东西的引进总归是经过深思熟虑的，希望大家一起玩起来。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/10/POST提交数据的四种方式解析/" rel="next" title="POST提交数据的四种方式解析">
                <i class="fa fa-chevron-left"></i> POST提交数据的四种方式解析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Gordon Rawe" />
          <p class="site-author-name" itemprop="name">Gordon Rawe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Streams如何工作？"><span class="nav-number">2.</span> <span class="nav-text">Streams如何工作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#streams分类"><span class="nav-number">3.</span> <span class="nav-text">streams分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理顺序"><span class="nav-number">4.</span> <span class="nav-text">处理顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行效率与steream执行链顺序的关系"><span class="nav-number">5.</span> <span class="nav-text">执行效率与steream执行链顺序的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流复用"><span class="nav-number">6.</span> <span class="nav-text">流复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级操作"><span class="nav-number">7.</span> <span class="nav-text">高级操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Collect-收集"><span class="nav-number">7.1.</span> <span class="nav-text">Collect(收集)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FlatMap（平铺变换，我自己这么叫的）"><span class="nav-number">7.2.</span> <span class="nav-text">FlatMap（平铺变换，我自己这么叫的）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Reduce（归并）"><span class="nav-number">7.3.</span> <span class="nav-text">Reduce（归并）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Streams（并行流）"><span class="nav-number">8.</span> <span class="nav-text">Parallel Streams（并行流）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  &copy; Copyright All rights are reserved by 
  <a href="https://github.com/gordon-rawe"><span class="author" itemprop="copyrightHolder">Gordon Rawe</span></a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
