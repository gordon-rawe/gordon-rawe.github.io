<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Sans Serif:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="引言本文要介绍的HashMap，与之前的List如ArrayList、LinkedList属于不同的数据结构，就后两者而言，反映的是两种思想：ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key">
<meta property="og:type" content="article">
<meta property="og:title" content="源码角度捋一捋HashMap">
<meta property="og:url" content="http://yoursite.com/2016/09/10/源码角度捋一捋HashMap/index.html">
<meta property="og:site_name" content="Gordon's Blog">
<meta property="og:description" content="引言本文要介绍的HashMap，与之前的List如ArrayList、LinkedList属于不同的数据结构，就后两者而言，反映的是两种思想：ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key">
<meta property="og:image" content="http://yoursite.com/one.png">
<meta property="og:image" content="http://yoursite.com/two.png">
<meta property="og:image" content="http://yoursite.com/three.png">
<meta property="og:updated_time" content="2016-09-10T08:24:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="源码角度捋一捋HashMap">
<meta name="twitter:description" content="引言本文要介绍的HashMap，与之前的List如ArrayList、LinkedList属于不同的数据结构，就后两者而言，反映的是两种思想：ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key">
<meta name="twitter:image" content="http://yoursite.com/one.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> 源码角度捋一捋HashMap | Gordon's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Gordon's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">still believe in that world can be reshaped by coding and we can benifit from it.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Blogs
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Timeline
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                源码角度捋一捋HashMap
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-10T15:22:29+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文要介绍的HashMap，与之前的List如ArrayList、LinkedList属于不同的数据结构，就后两者而言，反映的是两种思想：<br>ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢<br>LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便<br>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key-value的形式存在。</p>
<a id="more"></a>
<h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><h5 id="HashMap的整体框架"><a href="#HashMap的整体框架" class="headerlink" title="HashMap的整体框架"></a>HashMap的整体框架</h5><p>先来看看HashMap的整体框架：<br>框架图如下：</p>
<center><img src="one.png" alt=""></center>

<h4 id="来说一说HASHMAP"><a href="#来说一说HASHMAP" class="headerlink" title="来说一说HASHMAP"></a>来说一说HASHMAP</h4><p>要理解HashMap， 就必须要知道了解其底层的实现， 而底层实现里最重要的就是它的数据结构了，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br>在分析要理解HashMap源码前有必要对hashcode进行说明。<br>以下是关于HashCode的官方文档定义：</p>
<p><code>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。<br>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</code></p>
<p>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。</p>
<p>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p>
<p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。</p>
<p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。<code></code></p>
<p>以上这段官方文档的定义，我们可以抽出成以下几个关键点：</p>
<p>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p>
<p>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p>
<p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p>
<p>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。</p>
<p>再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的：</p>
<p><code>hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0 1 2 3 4 5 6 7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</code></p>
<p>但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊<code></code></p>
<h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><h5 id="HashMap定义"><a href="#HashMap定义" class="headerlink" title="HashMap定义"></a>HashMap定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<h5 id="HashMap属性"><a href="#HashMap属性" class="headerlink" title="HashMap属性"></a>HashMap属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认初始容量为16，必须为2的n次幂</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"></div><div class="line"><span class="comment">// 最大容量为2的30次方</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">// 默认加载因子为0.75f</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line"><span class="comment">// Entry数组，长度必须为2的n次幂</span></div><div class="line"><span class="keyword">transient</span> Entry[] table;</div><div class="line"></div><div class="line"><span class="comment">// 已存储元素的数量</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size ;</div><div class="line"></div><div class="line"><span class="comment">// 下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">// 加载因子</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor ;</div></pre></td></tr></table></figure>
<p>HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。</p>
<p>table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>size是HashMap的大小，它是HashMap保存的键值对的数量。<br>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。<br>loadFactor就是加载因子。<br>modCount是用来实现fail-fast机制的。<br>可以看出HashMap底层是用Entry数组存储数据，同时定义了初始容量，最大容量，加载因子等参数，至于为什么容量必须是2的幂，加载因子又是什么，下面再说，先来看一下Entry的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> K key ; </div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next; <span class="comment">// 指向下一个节点</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line"></div><div class="line">        Entry( <span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">            value = v;</div><div class="line">            next = n;</div><div class="line">            key = k;</div><div class="line">            hash = h;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">           V oldValue = value;</div><div class="line">            value = newValue;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry e = (Map.Entry)o;</div><div class="line">            Object k1 = getKey();</div><div class="line">            Object k2 = e.getKey();</div><div class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">                Object v1 = getValue();</div><div class="line">                Object v2 = e.getValue();</div><div class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (key ==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</div><div class="line">                   ( value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 当向HashMap中添加元素的时候调用这个方法，这里没有实现是供子类回调用</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 当从HashMap中删除元素的时候调动这个方法 ，这里没有实现是供子类回调用</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry是HashMap的内部类，它继承了Map中的Entry接口，它定义了键(key)，值(value)，和下一个节点的引用(next)，以及hash值。很明确的可以看出Entry是什么结构，它是单线链表的一个节点。也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</p>
<center><img src="two.png" alt=""></center>

<p>为什么会有这样的设计？之前介绍的List中查询时需要遍历所有的数组，为了解决这个问题HashMap采用hash算法将key散列为一个int值，这个int值对应到数组的下标，再做查询操作的时候，拿到key的散列值，根据数组下标就能直接找到存储在数组的元素。但是由于hash可能会出现相同的散列值，为了解决冲突，HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的。找到数组下标取出链表，再遍历链表是不是比遍历整个数组效率好的多呢？</p>
<p>我们来看一下HashMap的具体实现。</p>
<h5 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个指定初始容量和加载因子的HashMap</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="comment">// 初始容量和加载因子合法校验</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="comment">// 确保容量为2的n次幂，是capacity为大于initialCapacity的最小的2的n次幂</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 赋值加载因子</span></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">// 赋值扩容临界值</span></div><div class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</div><div class="line">    <span class="comment">// 初始化hash表</span></div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个指定初始容量的HashMap</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的HashMap</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个指定map的HashMap，所创建HashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt; ? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="comment">// 确保最小初始容量为16，并保证可以容纳指定map</span></div><div class="line">    <span class="keyword">this</span>(Math.max(( <span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</div><div class="line">                  DEFAULT_INITIAL_CAPACITY ), DEFAULT_LOAD_FACTOR);</div><div class="line">    putAllForCreate(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap提供了四个构造函数：</p>
<p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。<br>public HashMap(Map&lt; ? extends K, ? extends V&gt; m)：包含“子Map”的构造函数<br>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>
<h5 id="API方法摘要"><a href="#API方法摘要" class="headerlink" title="API方法摘要"></a>API方法摘要</h5><center><img src="three.png" alt=""></center>

<h4 id="HashMap源码解析-基于JDK1-6-0-45"><a href="#HashMap源码解析-基于JDK1-6-0-45" class="headerlink" title="HashMap源码解析(基于JDK1.6.0_45)"></a>HashMap源码解析(基于JDK1.6.0_45)</h4><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>HashMap会对null值key进行特殊处理，总是放到table[0]位置<br>put过程是先计算hash然后通过hash与table.length取摸计算index值，然后将key放到table[index]位置，当table[index]已存在其它元素时，会在table[index]位置形成一个链表，将新添加的元素放在table[index]，原来的元素通过Entry的next进行链接，这样以链表形式解决hash冲突问题，当元素数量达到临界值(capactiyfactor)时，则进行扩容，是table数组长度变为table.length2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value); <span class="comment">//处理null值</span></div><div class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//计算在数组中的存储位置</span></div><div class="line">    <span class="comment">//遍历table[i]位置的链表，查找相同的key，若找到则使用新的value替换掉原来的oldValue并返回oldValue</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//若没有在table[i]位置找到相同的key，则添加key到table[i]位置，新的元素总是在table[i]位置的第一个元素，原来的元素后移</span></div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// 取出数组第1个位置（下标等于0）的节点，如果存在则覆盖不存在则新增，和上面的put一样不多讲，</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table [<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e. value;</div><div class="line">                e. value = value;</div><div class="line">                e.recordAccess( <span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        <span class="comment">// 如果key等于null，则hash值等于0</span></div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//添加key到table[bucketIndex]位置，新的元素总是在table[bucketIndex]的第一个元素，原来的元素后移</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    <span class="comment">//判断元素个数是否达到了临界值，若已达到临界值则扩容，table长度翻倍</span></div><div class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p>同样当key为null时会进行特殊处理，在table[0]的链表上查找key为null的元素<br>get的过程是先计算hash然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();<span class="comment">//处理null值</span></div><div class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></div><div class="line">    <span class="comment">//在table[index]遍历查找key，若找到则返回value，找不到返回null</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != <span class="keyword">null</span>;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>remove方法和put get类似，计算hash，计算index，然后遍历查找，将找到的元素从table[index]链表移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key删除元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e. value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key删除链表节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 计算key的hash值</span></div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">    <span class="comment">// 根据hash值计算key在数组的索引位置</span></div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length );</div><div class="line">    <span class="comment">// 找到该索引出的第一个节点</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历链表（从链表第一个节点开始next），找出相同的key，</span></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e. next;</div><div class="line">        Object k;</div><div class="line">        <span class="comment">// 如果hash值和key都相等，则认为相等</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e. key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            <span class="comment">// 修改版本+1</span></div><div class="line">            modCount++;</div><div class="line">            <span class="comment">// 计数器减1</span></div><div class="line">            size--;</div><div class="line">            <span class="comment">// 如果第一个就是要删除的节点（第一个节点没有上一个节点，所以要分开判断）</span></div><div class="line">            <span class="keyword">if</span> (prev == e)</div><div class="line">                <span class="comment">// 则将下一个节点放到table[i]位置（要删除的节点被覆盖）</span></div><div class="line">                table[i] = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">             <span class="comment">// 否则将上一个节点的next指向当要删除节点下一个（要删除节点被忽略，没有指向了）</span></div><div class="line">                prev. next = next;</div><div class="line">            e.recordRemoval( <span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 返回删除的节点内容</span></div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 保存当前节点为下次循环的上一个节点</span></div><div class="line">        prev = e;</div><div class="line">        <span class="comment">// 下次循环</span></div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h5><p>clear方法非常简单，就是遍历table然后把每个位置置为null，同时修改元素个数为0<br>需要注意的是clear方法只会清楚里面的元素，并不会重置capactiy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        Entry[] tab = table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line">        size = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>resize方法在hashmap中并没有公开，这个方法实现了非常重要的hashmap扩容，具体过程为：先创建一个容量为table.length2的新table，修改临界值，然后把table里面元素计算hash值并使用hash与table.length2重新计算index放入到新的table里面<br>这里需要注意下是用每个元素的hash全部重新计算index，而不是简单的把原table对应index位置元素简单的移动到新table对应位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( <span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">        <span class="comment">// 当前数组</span></div><div class="line">        Entry[] oldTable = table;</div><div class="line">        <span class="comment">// 当前数组容量</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length ;</div><div class="line">        <span class="comment">// 如果当前数组已经是默认最大容量MAXIMUM_CAPACITY ，则将临界值改为Integer.MAX_VALUE 返回</span></div><div class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 使用新的容量创建一个新的链表数组</span></div><div class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">        <span class="comment">// 将当前数组中的元素都移动到新数组中</span></div><div class="line">        transfer(newTable);</div><div class="line">        <span class="comment">// 将当前数组指向新创建的数组</span></div><div class="line">        table = newTable;</div><div class="line">        <span class="comment">// 重新计算临界值</span></div><div class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Transfers all entries from current table to newTable.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line">        <span class="comment">// 当前数组</span></div><div class="line">        Entry[] src = table;</div><div class="line">        <span class="comment">// 新数组长度</span></div><div class="line">        <span class="keyword">int</span> newCapacity = newTable.length ;</div><div class="line">        <span class="comment">// 遍历当前数组的元素，重新计算每个元素所在数组位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src. length; j++) &#123;</div><div class="line">            <span class="comment">// 取出数组中的链表第一个节点</span></div><div class="line">            Entry&lt;K,V&gt; e = src[j];</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 将旧链表位置置空</span></div><div class="line">                src[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">// 循环链表，挨个将每个节点插入到新的数组位置中</span></div><div class="line">                do &#123;</div><div class="line">                    <span class="comment">// 取出链表中的当前节点的下一个节点</span></div><div class="line">                    Entry&lt;K,V&gt; next = e. next;</div><div class="line">                    <span class="comment">// 重新计算该链表在数组中的索引位置</span></div><div class="line">                    <span class="keyword">int</span> i = indexFor(e. hash, newCapacity);</div><div class="line">                    <span class="comment">// 将下一个节点指向newTable[i]</span></div><div class="line">                    e. next = newTable[i];</div><div class="line">                    <span class="comment">// 将当前节点放置在newTable[i]位置</span></div><div class="line">                    newTable[i] = e;</div><div class="line">                    <span class="comment">// 下一次循环</span></div><div class="line">                    e = next;</div><div class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>transfer方法中，由于数组的容量已经变大，也就导致hash算法indexFor已经发生变化，原先在一个链表中的元素，在新的hash下可能会产生不同的散列值，so所有元素都要重新计算后安顿一番。注意在do while循环的过程中，每次循环都是将下个节点指向newTable[i] ，是因为如果有相同的散列值i，上个节点已经放置在newTable[i]位置，这里还是下一个节点的next指向上一个节点（不知道这里是否能理解，画个图理解下吧）。</p>
<p>Map中的元素越多，hash冲突的几率也就越大，数组长度是固定的，所以导致链表越来越长，那么查询的效率当然也就越低下了。还记不记得同时数组容器的ArrayList怎么做的，扩容！而HashMap的扩容resize，需要将所有的元素重新计算后，一个个重新排列到新的数组中去，这是非常低效的，和ArrayList一样，在可以预知容量大小的情况下，提前预设容量会减少HashMap的扩容，提高性能。</p>
<p>再来看看加载因子的作用，如果加载因子越大，数组填充的越满，这样可以有效的利用空间，但是有一个弊端就是可能会导致冲突的加大，链表过长，反过来却又会造成内存空间的浪费。所以只能需要在空间和时间中找一个平衡点，那就是设置有效的加载因子。我们知道，很多时候为了提高查询效率的做法都是牺牲空间换取时间，到底该怎么取舍，那就要具体分析了。</p>
<h5 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h5><p>containsKey方法是先计算hash然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取哈希值</span></div><div class="line">    <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值</span></div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">    <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getEntry() 的作用就是返回“键为key”的键值对，它的实现源码中已经进行了说明。<br>这里需要强调的是：HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！</p>
<h5 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h5><p>containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 若“value为null”，则调用containsNullValue()查找</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> containsNullValue();</div><div class="line"></div><div class="line">    <span class="comment">// 若“value不为null”，则查找HashMap中是否有值为value的节点。</span></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</div><div class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</div><div class="line">            <span class="keyword">if</span> (value.equals(e.value))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>containsNullValue() 的作用判断HashMap中是否包含“值为null”的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</div><div class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</div><div class="line">            <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="entrySet-、values-、keySet-方法"><a href="#entrySet-、values-、keySet-方法" class="headerlink" title="entrySet()、values()、keySet()方法"></a>entrySet()、values()、keySet()方法</h5><p>它们3个的原理类似，这里以entrySet()为例来说明。<br>entrySet()的作用是返回“HashMap中所有Entry的集合”，它是一个集合。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回“HashMap的Entry集合”</span></div><div class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">    <span class="keyword">return</span> entrySet0();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></div><div class="line"><span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</div><div class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</div><div class="line">    <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// EntrySet对应的集合</span></div><div class="line"><span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">        <span class="keyword">return</span> newEntryIterator();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</div><div class="line">        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</div><div class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        HashMap.<span class="keyword">this</span>.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？</p>
<p>下面我们就看看HashMap是如何通过entrySet()遍历的。<br>entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个“entry迭代器”</span></div><div class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Entry的迭代器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></div><div class="line"><span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 下一个元素</span></div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    <span class="comment">// expectedModCount用于实现fast-fail机制。</span></div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line">    <span class="comment">// 当前索引</span></div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">// 当前元素</span></div><div class="line">    Entry&lt;K,V&gt; current;</div><div class="line"></div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">// 将next指向table中第一个不为null的元素。</span></div><div class="line">            <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line"></div><div class="line">        <span class="comment">// 注意！！！</span></div><div class="line">        <span class="comment">// 一个Entry就是一个单向链表</span></div><div class="line">        <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></div><div class="line">        <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></div><div class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">        current = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除当前元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Object k = current.key;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。</p>
<h5 id="hash和indexFor"><a href="#hash和indexFor" class="headerlink" title="hash和indexFor"></a>hash和indexFor</h5><p>indexFor中的h &amp; (length-1)就相当于h%length，用于计算index也就是在table数组中的下标<br>hash方法是对hashcode进行二次散列，以获得更好的散列值<br>为了更好理解这里我们可以把这两个方法简化为 int index= key.hashCode()/table.length,以put中的方法为例可以这样替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></div><div class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//计算在数组中的存储位置</span></div><div class="line"><span class="comment">//上面这两行可以这样简化</span></div><div class="line"><span class="keyword">int</span> i = key.key.hashCode()%table.length;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="HashMap示例"><a href="#HashMap示例" class="headerlink" title="HashMap示例"></a>HashMap示例</h5><p>下面通过一个实例学习如何使用HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Map m=<span class="keyword">new</span> HashMap();</div><div class="line">        System.out.println(<span class="string">"添加put方法：(1,'a'),(2,'b'),(3,'c'),(4,'d')"</span>);</div><div class="line">        m.put(<span class="string">"1"</span>,<span class="string">"a"</span>);</div><div class="line">        m.put(<span class="string">"2"</span>,<span class="string">"b"</span>);</div><div class="line">        m.put(<span class="string">"3"</span>,<span class="string">"c"</span>);</div><div class="line">        m.put(<span class="string">"4"</span>,<span class="string">"d"</span>);</div><div class="line">        System.out.println(<span class="string">"打印添加后的map"</span>+m);</div><div class="line">        System.out.println(<span class="string">"删除第四个4元素"</span>);</div><div class="line">        m.remove(<span class="string">"4"</span>);</div><div class="line">        System.out.println(<span class="string">"打印map"</span>+m);</div><div class="line"></div><div class="line">        <span class="comment">// containsKey(Object key) :是否包含键key</span></div><div class="line">        System.out.println(<span class="string">"contains key 1 : "</span>+m.containsKey(<span class="string">"1"</span>));</div><div class="line">        <span class="comment">// containsValue(Object value) :是否包含值value</span></div><div class="line">        System.out.println(<span class="string">"contains value a : "</span>+m.containsValue(<span class="string">"a"</span>));</div><div class="line">        <span class="comment">// 通过Iterator遍历key-value</span></div><div class="line">        Iterator iterator = m.entrySet().iterator();</div><div class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">            Map.Entry entry = (Map.Entry)iterator.next();</div><div class="line">            System.out.println(<span class="string">"next : "</span>+ entry.getKey() +<span class="string">" - "</span>+entry.getValue());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// clear() ： 清空HashMap</span></div><div class="line">        m.clear();</div><div class="line">        <span class="comment">// isEmpty() : HashMap是否为空</span></div><div class="line">        System.out.println((m.isEmpty()?<span class="string">"map is empty"</span>:<span class="string">"map is not empty"</span>) );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">添加put方法：(<span class="number">1</span>,<span class="string">'a'</span>),(<span class="number">2</span>,<span class="string">'b'</span>),(<span class="number">3</span>,<span class="string">'c'</span>),(<span class="number">4</span>,<span class="string">'d'</span>)</div><div class="line">打印添加后的map&#123;<span class="number">3</span>=c, <span class="number">2</span>=b, <span class="number">1</span>=a, <span class="number">4</span>=d&#125;</div><div class="line">删除第四个<span class="number">4</span>元素</div><div class="line">打印map&#123;<span class="number">3</span>=c, <span class="number">2</span>=b, <span class="number">1</span>=a&#125;</div><div class="line">contains key <span class="number">1</span> : <span class="keyword">true</span></div><div class="line">contains value a : <span class="keyword">true</span></div><div class="line">next : <span class="number">3</span> - c</div><div class="line">next : <span class="number">2</span> - b</div><div class="line">next : <span class="number">1</span> - a</div><div class="line">map is empty</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h5><p>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全<br>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）<br>HashMap可以使用null作为key，而Hashtable则不允许null作为key<br>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事<br>HashMap以null作为key时，总是存储在table数组的第一个节点上<br>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类<br>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75<br>HashMap扩容时是当前容量翻倍即:capacity2，Hashtable扩容时是容量翻倍+1即:capacity2+1<br>HashMap和Hashtable的底层实现都是数组+链表结构实现<br>两者计算hash的方法不同<br>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = key.hashCode();</div><div class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div></pre></td></tr></table></figure></p>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">     <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">     <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">     <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>本文摘自：<a href="http://www.jianshu.com/p/085a5ba2aca8" target="_blank" rel="external">http://www.jianshu.com/p/085a5ba2aca8</a>  ，不得不说，这是一个大神。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/10/源码角度捋一捋ArrayList/" rel="next" title="源码角度捋一捋ArrayList">
                <i class="fa fa-chevron-left"></i> 源码角度捋一捋ArrayList
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/10/源码角度捋一捋LinkedList/" rel="prev" title="源码角度捋一捋LinkedList">
                源码角度捋一捋LinkedList <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Gordon Rawe" />
          <p class="site-author-name" itemprop="name">Gordon Rawe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整体框架"><span class="nav-number">2.</span> <span class="nav-text">整体框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap的整体框架"><span class="nav-number">2.1.</span> <span class="nav-text">HashMap的整体框架</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#来说一说HASHMAP"><span class="nav-number">3.</span> <span class="nav-text">来说一说HASHMAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap简介"><span class="nav-number">4.</span> <span class="nav-text">HashMap简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap定义"><span class="nav-number">4.1.</span> <span class="nav-text">HashMap定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap属性"><span class="nav-number">4.2.</span> <span class="nav-text">HashMap属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap构造函数"><span class="nav-number">4.3.</span> <span class="nav-text">HashMap构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#API方法摘要"><span class="nav-number">4.4.</span> <span class="nav-text">API方法摘要</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap源码解析-基于JDK1-6-0-45"><span class="nav-number">5.</span> <span class="nav-text">HashMap源码解析(基于JDK1.6.0_45)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put方法"><span class="nav-number">5.1.</span> <span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get方法"><span class="nav-number">5.2.</span> <span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove方法"><span class="nav-number">5.3.</span> <span class="nav-text">remove方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#clear-方法"><span class="nav-number">5.4.</span> <span class="nav-text">clear()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#resize方法"><span class="nav-number">5.5.</span> <span class="nav-text">resize方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#containsKey方法"><span class="nav-number">5.6.</span> <span class="nav-text">containsKey方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#containsValue方法"><span class="nav-number">5.7.</span> <span class="nav-text">containsValue方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#entrySet-、values-、keySet-方法"><span class="nav-number">5.8.</span> <span class="nav-text">entrySet()、values()、keySet()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hash和indexFor"><span class="nav-number">5.9.</span> <span class="nav-text">hash和indexFor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap示例"><span class="nav-number">5.10.</span> <span class="nav-text">HashMap示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap和Hashtable的区别"><span class="nav-number">6.1.</span> <span class="nav-text">HashMap和Hashtable的区别</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  &copy; Copyright All rights are reserved by 
  <a href="https://github.com/gordon-rawe"><span class="author" itemprop="copyrightHolder">Gordon Rawe</span></a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
